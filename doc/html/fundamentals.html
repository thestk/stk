<HTML>
<HEAD>
<TITLE>The Synthesis ToolKit in C++ (STK)</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<img src="princeton.gif"> &nbsp; <img src="ccrma.gif"> &nbsp; <img src="mcgill.gif"><P>
<a class="qindex" href="index.html">Home</a> &nbsp; <a class="qindex" href="information.html">Information</a> &nbsp; <a class="qindex" href="classes.html">Classes</a> &nbsp; <a class="qindex" href="download.html">Download</a> &nbsp; <a class="qindex" href="usage.html">Usage</a> &nbsp; <a class="qindex" href="maillist.html">Mail List</a> &nbsp; <a class="qindex" href="system.html">Requirements</a> &nbsp; <a class="qindex" href="links.html">Links</a> &nbsp; <a class="qindex" href="tutorial.html">Tutorial</a></CENTER>
<HR>
<!-- Generated by Doxygen 1.3.4 -->
<h1><a class="anchor" name="fundamentals">STK Fundamentals</a></h1>The Synthesis ToolKit is implemented in the C++ programming language. STK does not attempt to provide a new programming environment or paradigm but rather provides a set of objects which can be used within a normal C++ programming framework. Therefore, it is expected that users of STK will have some familiarity with C/C++ programming concepts. That said, the STK classes do have some particular idiosyncrasies that we will mention here.<h2><a class="anchor" name="Signal">
Computations:</a></h2>
Audio and control signals throughout STK use a floating-point data type, <code>StkFloat</code>, the exact precision of which can be controlled via a typedef statement in <a class="el" href="Stk_8h.html">Stk.h</a>. By default, an StkFloat is a double-precision floating-point value. Thus, the ToolKit can use any normalization scheme desired. The base instruments and algorithms are implemented with a general audio sample dynamic maximum of +/-1.0.<p>
In general, the computation and/or passing of values is performed on a "single-sample" basis. For example, the <a class="el" href="classNoise.html">Noise</a> class outputs random floating-point numbers in the range +/-1.0. The computation of such values occurs in the <a class="el" href="classNoise.html#a4">Noise::tick()</a> function. The following program will generate 20 random floating-point (<code>StkFloat</code>) values in the range -1.0 to +1.0:<p>
<div class="fragment"><pre><span class="preprocessor">#include "Noise.h"</span>

<span class="keywordtype">int</span> main()
{
  StkFloat output;
  <a class="code" href="classNoise.html">Noise</a> noise;

  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;20; i++ ) {
    output = noise.<a class="code" href="classNoise.html#a4">tick</a>();
    std::cout &lt;&lt; <span class="stringliteral">"i = "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" : output = "</span> &lt;&lt; output &lt;&lt; std::endl;
  }

  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
Nearly all STK classes implement <code>tick()</code> functions which take and/or return sample values. Within the <code>tick()</code> function, the fundamental sample calculations are performed for a given class. Most STK classes consume/generate a single sample per operation and their <code>tick()</code> method takes/returns each sample "by value". In addition, every class implementing a <code>tick()</code> function also provides one or more overloaded <code>tick()</code> functions which can be used for vectorized computations, as shown in the next example.<p>
<div class="fragment"><pre><span class="preprocessor">#include "Noise.h"</span>

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classStkFrames.html">StkFrames</a> output(20);   <span class="comment">// initialize StkFrames to 20 elements (defaults: 1 channel, interleaved)</span>
  <a class="code" href="classNoise.html">Noise</a> noise;

  noise.<a class="code" href="classNoise.html#a4">tick</a>( output );
  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;output.<a class="code" href="classStkFrames.html#a4">size</a>(); i++ ) {
    std::cout &lt;&lt; <span class="stringliteral">"i = "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" : output = "</span> &lt;&lt; output[i] &lt;&lt; std::endl;
  }

  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
In this way, it might be possible to achieve improved processing efficiency using vectorized computations. The <a class="el" href="classStkFrames.html">StkFrames</a> class is a new addition to the ToolKit to provide a general "mechanism" for handling and passing vectorized, multi-channel audio data. The <a class="el" href="classStkFrames.html">StkFrames</a> "type" provides functions to set and/or determine the number of audio channels and sample frames it holds, as well as the format (interleaved or non-interleaved) of its data.<h2><a class="anchor" name="STK">
Inheritance:</a></h2>
Nearly all STK classes inherit from the <a class="el" href="classStk.html">Stk</a> abstract base class, which provides common functionality related to error reporting, sample rate control, and byte swapping. Several other base classes exist which roughly group many of the classes according to function as follows:<p>
<ul>
<li><a class="el" href="classGenerator.html">Generator</a>: source signal unit generator classes [<a class="el" href="classEnvelope.html">Envelope</a>, <a class="el" href="classADSR.html">ADSR</a>, <a class="el" href="classAsymp.html">Asymp</a>, <a class="el" href="classNoise.html">Noise</a>, <a class="el" href="classSubNoise.html">SubNoise</a>, <a class="el" href="classModulate.html">Modulate</a>, <a class="el" href="classSingWave.html">SingWave</a>]</li><li><a class="el" href="classFilter.html">Filter</a>: digital filtering classes [<a class="el" href="classOneZero.html">OneZero</a>, <a class="el" href="classOnePole.html">OnePole</a>, <a class="el" href="classPoleZero.html">PoleZero</a>, <a class="el" href="classTwoZero.html">TwoZero</a>, <a class="el" href="classTwoPole.html">TwoPole</a>, <a class="el" href="classBiQuad.html">BiQuad</a>, <a class="el" href="classFormSwep.html">FormSwep</a>, <a class="el" href="classDelay.html">Delay</a>, <a class="el" href="classDelayL.html">DelayL</a>, <a class="el" href="classDelayA.html">DelayA</a>]</li><li><a class="el" href="classFunction.html">Function</a>: input to output function mappings [<a class="el" href="classTable.html">Table</a>, <a class="el" href="classBowTable.html">BowTable</a>, <a class="el" href="classJetTable.html">JetTable</a>, <a class="el" href="classReedTable.html">ReedTable</a>]</li><li><a class="el" href="classInstrmnt.html">Instrmnt</a>: sound synthesis algorithms, including physical, <a class="el" href="classFM.html">FM</a>, modal, and particle models</li><li><a class="el" href="classEffect.html">Effect</a>: sound processing effect classes [<a class="el" href="classEcho.html">Echo</a>, <a class="el" href="classChorus.html">Chorus</a>, <a class="el" href="classPitShift.html">PitShift</a>, <a class="el" href="classPRCRev.html">PRCRev</a>, <a class="el" href="classJCRev.html">JCRev</a>, <a class="el" href="classNRev.html">NRev</a>]</li><li><a class="el" href="classWvOut.html">WvOut</a>: audio file and streaming output classes [<a class="el" href="classRtWvOut.html">RtWvOut</a>, <a class="el" href="classTcpWvOut.html">TcpWvOut</a>]</li><li><a class="el" href="classWvIn.html">WvIn</a>: audio file and streaming input classes [<a class="el" href="classWaveLoop.html">WaveLoop</a>, <a class="el" href="classRtWvIn.html">RtWvIn</a>, <a class="el" href="classTcpWvIn.html">TcpWvIn</a>]</li></ul>
<p>
[<a href="hello.html">Next tutorial</a>] &nbsp; [<a href="tutorial.html">Main tutorial page</a>] <HR>

<table>
  <tr><td><A HREF="http://ccrma.stanford.edu/software/stk/"><I>The Synthesis ToolKit in C++ (STK)</I></A></td></tr>
  <tr><td>&copy;1995-2004 Perry R. Cook and Gary P. Scavone. All Rights Reserved.</td></tr>
</table>

</BODY>
</HTML>
