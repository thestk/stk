<HTML>
<HEAD>
<TITLE>The Synthesis ToolKit in C++ (STK)</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<img src="princeton.gif"> &nbsp; <img src="ccrma.gif"> &nbsp; <img src="mcgill.gif"><P>
<a class="qindex" href="index.html">Home</a> &nbsp; <a class="qindex" href="information.html">Information</a> &nbsp; <a class="qindex" href="classes.html">Classes</a> &nbsp; <a class="qindex" href="download.html">Download</a> &nbsp; <a class="qindex" href="usage.html">Usage</a> &nbsp; <a class="qindex" href="maillist.html">Mail List</a> &nbsp; <a class="qindex" href="system.html">Requirements</a> &nbsp; <a class="qindex" href="links.html">Links</a> &nbsp; <a class="qindex" href="tutorial.html">Tutorial</a></CENTER>
<HR>
<!-- Generated by Doxygen 1.4.4 -->
<h1><a class="anchor" name="compile">Compiling</a></h1>The Synthesis ToolKit can be used in a variety of ways, depending on your particular needs. Some people choose the classes they need for a particular project and copy those to their working directory. Others create <code>Makefiles</code> which compile project-specific class objects from common <code>src</code> and <code>include</code> directories. And still others like to compile and link to a common library of object files. STK was not designed with one particular style of use in mind.<h2><a class="anchor" name="rtvsnonrt">
"Realtime" vs. "Non-Realtime"</a></h2>
Most of the Synthesis ToolKit classes are platform independent. That means that they should compile on any reasonably current C++ compiler. The functionality needed for realtime audio and MIDI input/output, as well as realtime control message acquistion, is inherently platform and operating-system (OS) <em>dependent</em>. STK classes which require specific platform/OS support include <a class="el" href="classRtAudio.html">RtAudio</a>, <a class="el" href="classRtWvOut.html">RtWvOut</a>, <a class="el" href="classRtWvIn.html">RtWvIn</a>, <a class="el" href="classRtDuplex.html">RtDuplex</a>, <a class="el" href="classRtMidi.html">RtMidi</a>, <a class="el" href="classInetWvIn.html">InetWvIn</a>, <a class="el" href="classInetWvOut.html">InetWvOut</a>, <a class="el" href="classSocket.html">Socket</a>, <a class="el" href="classUdpSocket.html">UdpSocket</a>, <a class="el" href="classTcpServer.html">TcpServer</a>, <a class="el" href="classTcpClient.html">TcpClient</a>, <a class="el" href="classThread.html">Thread</a>, and <a class="el" href="classMutex.html">Mutex</a>. These classes currently can only be compiled on Linux, Irix, Macintosh OS X, and Windows systems.<p>
Without the "realtime" classes, it is still possible to read SKINI scorefiles for control input and to read and write to/from a variety of audio file formats (WAV, SND, AIFF, MAT-file, and RAW). If compiling for a "little-endian" host processor, the <code>__LITTLE_ENDIAN__</code> preprocessor definition should be provided.<h2><a class="anchor" name="unix">
Unix Systems:</a></h2>
STK compiles with realtime support on the following flavors of the Unix operating system: Linux, Irix, and Macintosh OS X. Aside from differences in compilers, audio/MIDI APIs, and host endianness, the steps necessary to compile STK programs and classes on these platforms are the same. The following table summarizes these differences.<p>
<center> <table border="2" cols="5" width="100%" cellspacing="3" cellpadding="3">
<tr bgcolor="beige">
<td width="5%"><b>OS:</b> </td><td width="5%"><b>Realtime Audio/MIDI API:</b> </td><td width="5%"><b>Preprocessor Definition:</b> </td><td width="5%"><b>Library or Framework:</b>  </td></tr>
<tr>
<td>Linux </td><td>ALSA </td><td>__LINUX_ALSA__, __LINUX_ALSASEQ__, __LITTLE_ENDIAN__ </td><td><code>asound, pthread</code>  </td></tr>
<tr>
<td>Linux </td><td>Jack (audio only, use ALSA for MIDI support) </td><td>__LINUX_JACK__, __LINUX_ALSASEQ__, __LITTLE_ENDIAN__ </td><td><code>asound, pthread</code>  </td></tr>
<tr>
<td>Linux </td><td>OSS (audio only, use ALSA for MIDI support) </td><td>__LINUX_OSS__, __LINUX_ALSASEQ__, __LITTLE_ENDIAN__ </td><td><code>asound, pthread</code>  </td></tr>
<tr>
<td>Macintosh OS X </td><td>CoreAudio </td><td>__MACOSX_CORE__ </td><td><code>pthread, CoreAudio, CoreMIDI, CoreFoundation</code>  </td></tr>
<tr>
<td>Irix </td><td>AL </td><td>__IRIX_AL__, __IRIX_MD__ </td><td><code>audio, pthread</code>  </td></tr>
</table>
</center><p>
The available C++ compilers on any of these systems can vary.<p>
One approach in using STK is to simply copy the class files needed for a particular program into a project directory. Taking the <code>sineosc.cpp</code> example from the previous tutorial chapter, it would be necessary to set up a directory that includes the files <code>sineosc.cpp</code>, the rawwave file <code>sinewave.raw</code> in a subdirectory called <code>rawwaves</code>, and the header and source files for the classes <a class="el" href="classStk.html">Stk</a>, <a class="el" href="classFileRead.html">FileRead</a>, <a class="el" href="classFileWrite.html">FileWrite</a>, <a class="el" href="classWvIn.html">WvIn</a>, <a class="el" href="classFileWvIn.html">FileWvIn</a>, <a class="el" href="classWaveLoop.html">WaveLoop</a>, <a class="el" href="classWvOut.html">WvOut</a>, and <a class="el" href="classFileWvOut.html">FileWvOut</a>. The program could then be compiled on a little-endian system, such as a PC running Linux, using the GNU g++ compiler as follows: <div class="fragment"><pre class="fragment">g++ -Wall -D__LITTLE_ENDIAN__ -o sineosc <a class="code" href="classStk.html">Stk</a>.cpp <a class="code" href="classFileRead.html">FileRead</a>.cpp <a class="code" href="classFileWrite.html">FileWrite</a>.cpp <a class="code" href="classWvIn.html">WvIn</a>.cpp <a class="code" href="classFileWvIn.html">FileWvIn</a>.cpp <a class="code" href="classWaveLoop.html">WaveLoop</a>.cpp <a class="code" href="classWvOut.html">WvOut</a>.cpp <a class="code" href="classFileWvOut.html">FileWvOut</a>.cpp sineosc.cpp
</pre></div><p>
Note that the <code>sineosc.cpp</code> example does not make use of realtime audio or MIDI input/output classes. For programs using any of the STK realtime classes mentioned above, it is necessary to specify an audio/MIDI API preprocessor definition and link with the appropriate libraries or frameworks.<p>
When working with a number of different projects that make use of ToolKit classes, the above approach can become cumbersome (especially when trying to synchronize with new STK releases). Most of the STK projects (e.g., demo, effects, ...) contain <code>Makefiles</code> (built by the configure script) which compile project-specific class objects from the distribution <code>src</code> and <code>include</code> directories. This approach makes it relatively easy when upgrading to a new STK release (by making path substitutions in the <code>Makefile</code> or by moving the projects to a similar relative path within the new STK source tree). A <code>Makefile</code> is provided in the <code>projects/examples</code> directory for compiling all the tutorial programs, as well as other example programs. To compile the <code>sineosc.cpp</code> program, for example, one need only type <code>make sineosc</code> from within the <code>projects/examples</code> directory.<h3><a class="anchor" name="library">
Library Use:</a></h3>
The STK distribution provides a <code>Makefile</code> that can be used on Unix systems to build a static library. After unpacking the distribution (<code>tar -xzf stk-4.x.x.tar.gz</code>), run the configure script by typing <code>./configure</code> from the top level distribution directory (see the INSTALL file in the same directory for more information). Then from within the <code>src</code> directory, type <code>make</code>. After a successful build, you may wish to move the library (<code>libstk.a</code>) and the contents of the <code>include</code> directory to standard library and include search paths on your system. For example, the linux RPM distribution of STK puts the library in <code>/usr/lib/</code> and the STK header files in <code>/usr/include/stk/</code>.<p>
Assuming the library is located in a standard search path and the header files are located in <code>/usr/include/stk/</code>, the <code>sineosc.cpp</code> example from the previous tutorial chapter can be compiled on a little-endian system using the GNU g++ compiler as follows:<p>
<div class="fragment"><pre class="fragment">g++ -Wall -D__LITTLE_ENDIAN__ -I/usr/include/stk -o sineosc sineosc.cpp -lstk
</pre></div><p>
With the header files in a standard search path, it is possible to modify the <code>#include</code> statements in the <code>sineosc.cpp</code> program as follows:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "stk/WaveLoop.h"</span>
<span class="preprocessor">#include "stk/FileWvOut.h"</span>
</pre></div><p>
and then compile without an explicit include path argument to the compiler:<p>
<div class="fragment"><pre class="fragment">g++ -Wall -D__LITTLE_ENDIAN__ -o sineosc sineosc.cpp -lstk
</pre></div><h2><a class="anchor" name="compileWin">
Windows:</a></h2>
STK has been tested on Windows platforms using the Visual C++ compiler only. It is assumed here that you're familiar with Visual C++ and its particular idiosyncrasies.<p>
The approach when using Visual C++ is to build a project which includes the necessary ToolKit files from the distribution <code>src</code> and <code>include</code> directories. For the example program from the previous tutorial chapter, create a VC++ console application project, add the <a class="el" href="classStk.html">Stk</a>, <a class="el" href="classFileRead.html">FileRead</a>, <a class="el" href="classFileWrite.html">FileWrite</a>, <a class="el" href="classWvIn.html">WvIn</a>, <a class="el" href="classFileWvIn.html">FileWvIn</a>, <a class="el" href="classWaveLoop.html">WaveLoop</a>, <a class="el" href="classWvOut.html">WvOut</a>, and <a class="el" href="classFileWvOut.html">FileWvOut</a> class files, as well as <code>sineosc.cpp</code>, and make sure the <code>sinewave.raw</code> file is in the subdirectory <code>rawwaves</code>.<p>
For programs using any of the STK realtime classes mentioned above, it is necessary to link with the DirectSound (<code>dsound.lib</code>), <code>winmm.lib</code>, and <code>Wsock32.lib</code> libraries, select the multithreaded library, and provide the <code>__LITTLE_ENDIAN__</code>, <code>__WINDOWS_DS__</code>, and <code>__WINDOWS_MM__</code> preprocessor definitions.<p>
For Steinberg ASIO support, use the <code>__WINDOWS_ASIO__</code> preprocessor definition (and the <code>__WINDOWS_MM__</code> definition for <a class="el" href="classRtMidi.html">RtMidi</a> support), include all the files in the <code>src/asio/</code> directory (i.e., <code>asio.h,cpp</code>, <code>asiodrivers.h,cpp</code>, ...), and link with the <code>winmm.lib</code>, and <code>Wsock32.lib</code> libraries.<p>
[<a href="tutorial.html">Main tutorial page</a>] &nbsp; [<a href="filtering.html">Next tutorial</a>] <HR>

<table>
  <tr><td><A HREF="http://ccrma.stanford.edu/software/stk/"><I>The Synthesis ToolKit in C++ (STK)</I></A></td></tr>
  <tr><td>&copy;1995-2005 Perry R. Cook and Gary P. Scavone. All Rights Reserved.</td></tr>
</table>

</BODY>
</HTML>
